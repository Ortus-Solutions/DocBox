/**
 * This is the module descriptor and entry point for your module in the runtime.
 * The unique name of the module is the name of the directory on the modules folder
 * or the name property in the box.json file.
 * <p>
 * A BoxLang mapping will be created for you with the name of the module as well using the
 * this.mapping property.
 *<p>
 * Every module will have its own classloader that will be used to load the module libs and dependencies.
 */

class {

	/**
	 * --------------------------------------------------------------------------
	 * Injections
	 * --------------------------------------------------------------------------
	 */
	property name="moduleRecord";
	property name="boxRuntime";
	property name="functionService";
	property name="componentService";
	property name="interceptorService";
	property name="asyncService";
	property name="schedulerService";
	property name="datasourceService";
	property name="cacheService";
	property name="log";

	/**
	 * --------------------------------------------------------------------------
	 * Module Properties
	 * --------------------------------------------------------------------------
	 * Here is where you define the properties of your module that the module service
	 * will use to register and activate your module
	 */

	/**
	 * Your module version. Try to use semantic versioning
	 * @mandatory
	 */
	this.version = "@build.version@+@build.number@";

	/**
	 * The BoxLang mapping for your module.  All BoxLang modules are registered with an internal
	 * mapping prefix of : bxModules.{this.mapping}, /bxmodules/{this.mapping}. Ex: bxModules.test, /bxmodules/test
	 */
	this.mapping = "docbox";

	/**
	 * Who built the module
	 */
	this.author = "Luis Majano";

	/**
	 * The module description
	 */
	this.description = "API Documentation generator for BoxLang classes using JavaDoc conventions";

	/**
	 * The module web URL
	 */
	this.webURL = "https://www.ortussolutions.com";

	/**
	 * This boolean flag tells the module service to skip the module registration/activation process.
	 */
	this.enabled = true;

    /**
	 * The module dependencies that this module needs to be activated before this module is activated.
	 * A list of module slugs: Example: [ "bxai", "bxoshi" ]
	 */
	this.dependencies = [];

	/**
	 * --------------------------------------------------------------------------
	 * Module Methods
	 * --------------------------------------------------------------------------
	 */

	/**
	 * Called by the ModuleService on module registration
	 */
	function configure(){
		/**
		 * Every module has a settings configuration object
		 */
		settings = {
		};

		/**
		 * The module interceptors to register into the runtime
		 */
		interceptors = [
			// { class="interceptors.Listener", properties={} }
		];

		/**
		 * A list of custom interception points to register into the runtime
		 */
		customInterceptionPoints = [];
	}

	/**
	 * Called by the ModuleService on module activation
	 */
	function onLoad(){

	}

	/**
	 * Called by the ModuleService on module deactivation
	 */
	function onUnload(){

	}

	/**
	 * --------------------------------------------------------------------------
	 * Main CLI Command Entry Point
	 * --------------------------------------------------------------------------
	 * Creates documentation for BoxLang and CFML Classes JavaDoc style via DocBox
	 *
	 * You can pass the strategy options by prefixing them with 'strategy-'. So if a strategy takes
	 * in a property of 'outputDir' you will pass it as 'strategy-outputdir='
	 *
	 * Single source/mapping example:
	 * boxlang module:docbox source=/path/to/coldbox mapping=coldbox excludes=tests strategy-outputDir=/output/path strategy-projectTitle="My Docs"
	 *
	 * Multiple source/mapping example:
	 * boxlang module:docbox mappings:v1.models=/path/to/modules_app/v1/models mappings:v2.models=/path/to/modules_app/v2/models strategy-outputDir=/output/path strategy-projectTitle="My Docs"
	 *
	 * Multiple source mappings may be specified as JSON:
	 * boxlang module:docbox source="[{'dir':'../src/v1/models', 'mapping':'v1.models'}, {'dir':'../src/v2/models', 'mapping':'v2.models'}]" strategy-outputDir=docbox strategy-projectTitle="My API"
	 *
	 * @args The CLI arguments
	 */
	function main( args = [] ){
		// Get parsed arguments
		var positionalArgs = cliGetArgs().positionals;
		var options        = cliGetArgs().options;

		// Default values
		var strategy         = options.strategy ?: "docbox.strategy.api.HTMLAPIStrategy";
		var source           = options.source ?: "";
		var mapping          = options.mapping ?: "";
		var excludes         = options.excludes ?: "";
		var docboxSourceMaps = [];

		// Extract mappings from options (dynamic parameters with mappings: prefix)
		var mappings = {};
		for ( var key in options ) {
			if ( reFindNoCase( "^mappings:", key ) ) {
				mappings[ listLast( key, ":" ) ] = options[ key ];
			}
		}

		// If mappings has been provided, it overrides the traditional source and mapping arguments
		if ( !structIsEmpty( mappings ) ) {
			for ( var key in mappings ) {
				arrayAppend(
					docboxSourceMaps,
					{
						"dir"     : expandPath( mappings[ key ] ),
						"mapping" : key
					}
				);
			}
		} else if ( isJSON( source ) ) {
			// Handle JSON array of source mappings
			var sourceArray = deserializeJSON( source );
			for ( var item in sourceArray ) {
				arrayAppend(
					docboxSourceMaps,
					{
						"dir"     : expandPath( item.dir ),
						"mapping" : item.mapping
					}
				);
			}
		} else if ( len( source ) && len( mapping ) ) {
			// Basic usage: provide a source directory and a mapping as separate arguments
			arrayAppend(
				docboxSourceMaps,
				{
					"dir"     : expandPath( source ),
					"mapping" : mapping
				}
			);
		}

		// Validate we have at least one source mapping
		if ( arrayLen( docboxSourceMaps ) == 0 ) {
			cliPrintln( "ERROR: No valid source mappings found." );
			cliPrintln( "" );
			cliPrintln( "Usage examples:" );
			cliPrintln( "  boxlang module:docbox source=/path/to/code mapping=myapp strategy-outputDir=/output" );
			cliPrintln( "  boxlang module:docbox mappings:v1=/path/v1 mappings:v2=/path/v2 strategy-outputDir=/output" );
			cliPrintln( "" );
			return;
		}

		// Inflate strategy properties from options with 'strategy-' prefix
		var properties = {};
		for ( var key in options ) {
			if ( reFindNoCase( "^strategy\-", key ) ) {
				var propName = listLast( key, "-" );
				properties[ propName ] = options[ key ];
				
				// Resolve outputDir to absolute path
				if ( propName == "outputDir" ) {
					properties[ propName ] = expandPath( options[ key ] );
				}
			}
		}

		// Validate outputDir
		if ( !structKeyExists( properties, "outputDir" ) ) {
			cliPrintln( "ERROR: strategy-outputDir is required" );
			return;
		}

		// Initialize DocBox with strategy and properties
		var docbox = new "bxModules.docbox.DocBox"(
			strategy   = strategy,
			properties = properties
		);

		// Provide feedback about sources
		cliPrintln( "DocBox Documentation Generator" );
		cliPrintln( "=============================" );
		cliPrintln( "" );
		
		for ( var tuple in docboxSourceMaps ) {
			if ( !directoryExists( tuple.dir ) ) {
				cliPrintln( "Warning: '#tuple.dir#' does not exist." );
			} else {
				cliPrintln( "Source:  #tuple.dir#" );
				cliPrintln( "Mapping: #tuple.mapping#" );
			}
		}
		
		cliPrintln( "Output:  #properties.outputDir#" );
		cliPrintln( "" );
		cliPrintln( "Starting generation, please wait..." );

		// Create mappings for source directories
		var appMappings = getApplicationSettings().mappings;
		for ( var tuple in docboxSourceMaps ) {
			appMappings[ "/" & replace( tuple.mapping, ".", "/", "all" ) ] = tuple.dir;
		}
		application action="update" mappings=appMappings;

		// Generate documentation
		try {
			docbox.generate(
				source   = docboxSourceMaps,
				excludes = excludes
			);
			
			cliPrintln( "" );
			cliPrintln( "âœ“ Generation complete!" );
			cliPrintln( "Documentation available at: #properties.outputDir#" );
		} catch ( any e ) {
			cliPrintln( "ERROR: Generation failed" );
			cliPrintln( "Message: #e.message#" );
			cliPrintln( "Detail: #e.detail#" );
			if ( structKeyExists( e, "tagContext" ) && arrayLen( e.tagContext ) ) {
				cliPrintln( "Location: #e.tagContext[1].template#:#e.tagContext[1].line#" );
			}
		}
	}

}
