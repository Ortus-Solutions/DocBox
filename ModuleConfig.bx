/**
 * This is the module descriptor and entry point for your module in the runtime.
 * The unique name of the module is the name of the directory on the modules folder
 * or the name property in the box.json file.
 * <p>
 * A BoxLang mapping will be created for you with the name of the module as well using the
 * this.mapping property.
 *<p>
 * Every module will have its own classloader that will be used to load the module libs and dependencies.
 */

class {

	/**
	 * --------------------------------------------------------------------------
	 * Injections
	 * --------------------------------------------------------------------------
	 */
	property name="moduleRecord";
	property name="boxRuntime";
	property name="functionService";
	property name="componentService";
	property name="interceptorService";
	property name="asyncService";
	property name="schedulerService";
	property name="datasourceService";
	property name="cacheService";
	property name="log";

	/**
	 * --------------------------------------------------------------------------
	 * Module Properties
	 * --------------------------------------------------------------------------
	 * Here is where you define the properties of your module that the module service
	 * will use to register and activate your module
	 */

	/**
	 * Your module version. Try to use semantic versioning
	 * @mandatory
	 */
	this.version = "@build.version@+@build.number@";

	/**
	 * The BoxLang mapping for your module.  All BoxLang modules are registered with an internal
	 * mapping prefix of : bxModules.{this.mapping}, /bxmodules/{this.mapping}. Ex: bxModules.test, /bxmodules/test
	 */
	this.mapping = "docbox";

	/**
	 * Who built the module
	 */
	this.author = "Luis Majano";

	/**
	 * The module description
	 */
	this.description = "API Documentation generator for BoxLang classes using JavaDoc conventions";

	/**
	 * The module web URL
	 */
	this.webURL = "https://www.ortussolutions.com";

	/**
	 * This boolean flag tells the module service to skip the module registration/activation process.
	 */
	this.enabled = true;

    /**
	 * The module dependencies that this module needs to be activated before this module is activated.
	 * A list of module slugs: Example: [ "bxai", "bxoshi" ]
	 */
	this.dependencies = [];

	/**
	 * --------------------------------------------------------------------------
	 * Module Methods
	 * --------------------------------------------------------------------------
	 */

	/**
	 * Called by the ModuleService on module registration
	 */
	function configure(){
		/**
		 * Every module has a settings configuration object
		 */
		settings = {
		};

		/**
		 * The module interceptors to register into the runtime
		 */
		interceptors = [
			// { class="interceptors.Listener", properties={} }
		];

		/**
		 * A list of custom interception points to register into the runtime
		 */
		customInterceptionPoints = [];
	}

	/**
	 * Called by the ModuleService on module activation
	 */
	function onLoad(){

	}

	/**
	 * Called by the ModuleService on module deactivation
	 */
	function onUnload(){

	}

	/**
	 * --------------------------------------------------------------------------
	 * Main CLI Command Entry Point
	 * --------------------------------------------------------------------------
	 * Creates documentation for BoxLang and CFML Classes JavaDoc style via DocBox
	 *
	 * You can pass the strategy options by prefixing them with 'strategy-'. So if a strategy takes
	 * in a property of 'outputDir' you will pass it as 'strategy-outputdir='
	 *
	 * Single source/mapping example:
	 * boxlang module:docbox source=/path/to/coldbox mapping=coldbox excludes=tests strategy-outputDir=/output/path strategy-projectTitle="My Docs"
	 *
	 * Multiple source/mapping example:
	 * boxlang module:docbox mappings:v1.models=/path/to/modules_app/v1/models mappings:v2.models=/path/to/modules_app/v2/models strategy-outputDir=/output/path strategy-projectTitle="My Docs"
	 *
	 * Multiple source mappings may be specified as JSON:
	 * boxlang module:docbox source="[{'dir':'../src/v1/models', 'mapping':'v1.models'}, {'dir':'../src/v2/models', 'mapping':'v2.models'}]" strategy-outputDir=docbox strategy-projectTitle="My API"
	 *
	 * @args The CLI arguments
	 */
	function main( args = [] ){
		// Get parsed arguments
		var positionalArgs = cliGetArgs().positionals;
		var options        = cliGetArgs().options;

		// Check for --help or --version flags
		if ( structKeyExists( options, "help" ) || structKeyExists( options, "h" ) ) {
			return showHelp();
		}

		if ( structKeyExists( options, "version" ) || structKeyExists( options, "v" ) ) {
			return showVersion();
		}

		// Route to generateDocs if no special flags
		return generateDocs( positionalArgs, options );
	}

	/**
	 * Show version information
	 */
	function showVersion(){
		println( "" );
		println( "ğŸ“š DocBox - API Documentation Generator" );
		println( "Version: #this.version#" );
		println( "Author:  #this.author#" );
		println( "Website: #this.webURL#" );
		println( "" );
	}

	/**
	 * Show help information
	 */
	function showHelp(){
		println( "" );
		println( "ğŸ“š â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" );
		println( "   DocBox - JavaDoc Style API Documentation Generator" );
		println( "   Version: #this.version#" );
		println( "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" );
		println( "" );
		println( "ğŸ¯ USAGE:" );
		println( "   boxlang module:docbox [options]" );
		println( "" );
		println( "âš™ï¸  OPTIONS:" );
		println( "   --help, -h              Show this help information" );
		println( "   --version, -v           Show version information" );
		println( "   source=<path>           Source directory to document" );
		println( "   mapping=<name>          Base mapping for the source folder" );
		println( "   excludes=<regex>        Regex pattern to exclude files/folders" );
		println( "   mappings:<name>=<path>  Define multiple source mappings" );
		println( "   strategy=<class>        Documentation strategy class" );
		println( "                           (default: docbox.strategy.api.HTMLAPIStrategy)" );
		println( "   strategy-*              Any strategy-specific option (see examples)" );
		println( "" );
		println( "ğŸ“‹ STRATEGY OPTIONS:" );
		println( "   strategy-outputDir=<path>      ğŸ“ Output directory (required)" );
		println( "   strategy-projectTitle=<title>  ğŸ“– Project title for docs" );
		println( "   strategy-theme=<name>          ğŸ¨ Theme name (default/frames)" );
		println( "" );
		println( "ğŸ’¡ EXAMPLES:" );
		println( "" );
		println( "   ğŸ“Œ Basic usage:" );
		println( "      boxlang module:docbox source=/src/models mapping=models \" );
		println( "                             strategy-outputDir=/docs" );
		println( "" );
		println( "   ğŸ“Œ With project title and excludes:" );
		println( "      boxlang module:docbox source=/src mapping=myapp \" );
		println( "                             excludes=""(tests|build)"" \" );
		println( "                             strategy-outputDir=/docs \" );
		println( "                             strategy-projectTitle=""My API""" );
		println( "" );
		println( "   ğŸ“Œ Multiple source mappings:" );
		println( "      boxlang module:docbox mappings:v1=/src/v1/models \" );
		println( "                             mappings:v2=/src/v2/models \" );
		println( "                             strategy-outputDir=/docs \" );
		println( "                             strategy-projectTitle=""API Docs""" );
		println( "" );
		println( "   ğŸ“Œ Using frames theme:" );
		println( "      boxlang module:docbox source=/src mapping=app \" );
		println( "                             strategy-outputDir=/docs \" );
		println( "                             strategy-theme=frames" );
		println( "" );
		println( "   ğŸ“Œ JSON array format:" );
		println( "      boxlang module:docbox source=""[{'dir':'/src/models', 'mapping':'models'}]"" \" );
		println( "                             strategy-outputDir=/docs" );
		println( "" );
		println( "ğŸ”— MORE INFO:" );
		println( "   Documentation: #this.webURL#" );
		println( "   Repository:    https://github.com/Ortus-Solutions/DocBox" );
		println( "" );
		println( "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" );
		println( "" );
	}

	/**
	 * Generate documentation
	 *
	 * @positionalArgs Array of positional arguments
	 * @options Struct of named options
	 */
	function generateDocs( required array positionalArgs, required struct options ){
		// Default values
		var strategy         = options.strategy ?: "docbox.strategy.api.HTMLAPIStrategy";
		var source           = options.source ?: "";
		var mapping          = options.mapping ?: "";
		var excludes         = options.excludes ?: "";
		var docboxSourceMaps = [];

		// Extract mappings from options (dynamic parameters with mappings: prefix)
		var mappings = {};
		for ( var key in options ) {
			if ( reFindNoCase( "^mappings:", key ) ) {
				mappings[ listLast( key, ":" ) ] = options[ key ];
			}
		}

		// If mappings has been provided, it overrides the traditional source and mapping arguments
		if ( !structIsEmpty( mappings ) ) {
			for ( var key in mappings ) {
				arrayAppend(
					docboxSourceMaps,
					{
						"dir"     : expandPath( mappings[ key ] ),
						"mapping" : key
					}
				);
			}
		} else if ( isJSON( source ) ) {
			// Handle JSON array of source mappings
			var sourceArray = deserializeJSON( source );
			for ( var item in sourceArray ) {
				arrayAppend(
					docboxSourceMaps,
					{
						"dir"     : expandPath( item.dir ),
						"mapping" : item.mapping
					}
				);
			}
		} else if ( len( source ) && len( mapping ) ) {
			// Basic usage: provide a source directory and a mapping as separate arguments
			arrayAppend(
				docboxSourceMaps,
				{
					"dir"     : expandPath( source ),
					"mapping" : mapping
				}
			);
		}

		// Validate we have at least one source mapping
		if ( arrayLen( docboxSourceMaps ) == 0 ) {
			println( "ERROR: No valid source mappings found." );
			println( "" );
			println( "Usage examples:" );
			println( "  boxlang module:docbox source=/path/to/code mapping=myapp strategy-outputDir=/output" );
			println( "  boxlang module:docbox mappings:v1=/path/v1 mappings:v2=/path/v2 strategy-outputDir=/output" );
			println( "" );
			return;
		}

		// Inflate strategy properties from options with 'strategy-' prefix
		var properties = {};
		for ( var key in options ) {
			if ( reFindNoCase( "^strategy\-", key ) ) {
				var propName = listLast( key, "-" );
				properties[ propName ] = options[ key ];

				// Resolve outputDir to absolute path
				if ( propName == "outputDir" ) {
					properties[ propName ] = expandPath( options[ key ] );
				}
			}
		}

		// Validate outputDir
		if ( !structKeyExists( properties, "outputDir" ) ) {
			println( "ERROR: strategy-outputDir is required" );
			return;
		}

		// Initialize DocBox with strategy and properties
		var docbox = new "bxModules.docbox.DocBox"(
			strategy   = strategy,
			properties = properties
		);

		// Provide feedback about sources
		println( "DocBox Documentation Generator" );
		println( "=============================" );
		println( "" );

		for ( var tuple in docboxSourceMaps ) {
			if ( !directoryExists( tuple.dir ) ) {
				println( "Warning: '#tuple.dir#' does not exist." );
			} else {
				println( "Source:  #tuple.dir#" );
				println( "Mapping: #tuple.mapping#" );
			}
		}

		println( "Output:  #properties.outputDir#" );
		println( "" );
		println( "Starting generation, please wait..." );

		// Create mappings for source directories
		var appMappings = getApplicationSettings().mappings;
		for ( var tuple in docboxSourceMaps ) {
			appMappings[ "/" & replace( tuple.mapping, ".", "/", "all" ) ] = tuple.dir;
		}

		// Update mappings
		bx:application action="update" mappings=appMappings;

		// Generate documentation
		try {
			// docbox.generate(
			// 	source   = docboxSourceMaps,
			// 	excludes = excludes
			// );

			println( "" );
			println( "âœ“ Generation complete!" );
			println( "Documentation available at: #properties.outputDir#" );
		} catch ( any e ) {
			println( "ERROR: Generation failed" );
			println( "Message: #e.message#" );
			println( "Detail: #e.detail#" );
			if ( structKeyExists( e, "tagContext" ) && arrayLen( e.tagContext ) ) {
				println( "Location: #e.tagContext[1].template#:#e.tagContext[1].line#" );
			}
		}
	}

}
